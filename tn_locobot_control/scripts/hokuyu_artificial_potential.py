#!/usr/bin/env python
import rospy
from pyrobot import Robot
import time
import math
import numpy as np
from geometry_msgs.msg import Twist
from std_msgs.msg import Float32MultiArray
from sensor_msgs.msg import LaserScan

# define misc variables
namespace = "/pyRobot_web_data/"
twistTopic = "cmd_vel"
xyzArmOffsetTopic = "xyz_arm_offet"
# Laser angle and range constants 
LA_SAMPLES = 30
LA_MIN = -1.047198
LA_MAX = 1.047198
LR_MIN = 0.1
LR_MAX = 30.0
# Maximum obstacle distance and scale factor to use for avoidance behavior
OBS_MAX = 1.0
ETA = 3000

pub = rospy.Publisher("/artificial_potential/twist", Twist, queue_size=1)

def xyzArmCallback(msg):
    """
    This function extracts the xyz components of the Float32 array
    message request for cartesian end effector movement, checks for
    workspace compatibility, and republishes a safety-filtered version
    of the command.  Not yet implemented.

    params:
        msg (std_msgs/Float32MultiArray): the recieved message
    returns:
        None
    """
    global robot
    # extract message components and normalize - joystick provides [-100,100] and 
    # we will scale to [-0.1,0.1]
    arm_x = msg.data[0]/5000.0
    arm_y = msg.data[1]/5000.0
    arm_z = msg.data[2]/5000.0

    # if (arm_x == 0 and arm_y == 0 and arm_z == 0):
    #     rospy.loginfo("no arm command to alter")
    
    # else:
    #     rospy.loginfo("arm workspace safety checks not written, doing nothing")

def laserCallback(msg):
    """
    This callback simply stores the latest range return array from the laser 
    rangefinder in the local variable "laser_ranges" for use by other
    functions.
    
    params:
        None
    returns:
        None
    """
    global laser_ranges
    laser_ranges = np.array(msg.ranges)


def repubTwistCallback(msg):
    """
    This function takes in the Twist message generated by user input to control the Locobot's 
    base, biases it to avoid obstacles based on readings from the laser rangefinder using a pseudo-artificial 
    potential field strategy, and publishes the new Twist command.
    
    params:
        None
    returns:
        None
    """
    global laser_ranges
    fwdRev = msg.linear.x
    spin = msg.angular.z

    vel_inputs = np.array([0,0])
    # for i in range(10,laser_ranges.size-10):  // use this for high fidelity rangefinder... lots of samples
    #     if (laser_ranges[i]<OBS_MAX): # Nearby obstacle detected
    #         # if (laser_ranges[i]<laser_ranges[i-1] 
    #         #     and laser_ranges[i]<laser_ranges[i+1]): # Local minimum, object CPA
    #         if np.argmin(laser_ranges[i-10:i+10])==10:
    #             #mag = 100/laser_ranges[i] # Use the numerator as the scaling factor for avoidance behavior (currently 10/dist)
    #             mag = (ETA/2)*pow((1/laser_ranges[i] - (1/OBS_MAX)),4)
    #             angle = LA_MIN + i*2*LA_MAX/LA_SAMPLES
    #             rospy.loginfo("detection angle %s", str(angle))
    #             vel = -math.cos(angle)*mag
    #             lat = -math.sin(angle)*mag/2
    #             vel_inputs = np.append(vel_inputs,[vel,lat])
 
    # For current setup (30 returns)
    for i in range(1,laser_ranges.size-1):
        dist = OBS_MAX if abs(i-15) < 3 else OBS_MAX*2 #adjust range sensitivity depending on direction of obstacle (arm clnc)
        if (laser_ranges[i]<dist): # Nearby obstacle detected
            mag = (ETA/2)*pow((1/laser_ranges[i] - (1/OBS_MAX)),2)
            angle = LA_MIN + i*2*LA_MAX/LA_SAMPLES
            vel = -math.cos(angle)*mag 
            lat = -math.sin(angle)*mag 
            if (dist != OBS_MAX): # additional sensitivity tweaks for front vs. side sensors 
                vel = vel/10
                lat = lat/2
            vel_inputs = np.append(vel_inputs,[vel,lat])


    j=2
    out_fwdrev = 0
    out_spin = 0
    if (vel_inputs.size > 2):
        while(j<vel_inputs.size):
            out_fwdrev += vel_inputs[j]
            j+=1
            out_spin += vel_inputs[j]
            j+=1
   
    newmsg = Twist()
    if abs(fwdRev) > 10 or abs(spin) > 0.2:
        newmsg.linear.x = fwdRev + out_fwdrev/(j-1) # add half of obstacle vector to command 
        newmsg.angular.z = spin + (out_spin/(j-1))
        rospy.loginfo("original: %s, %s", fwdRev, spin)
        rospy.loginfo("new: %s, %s", newmsg.linear.x, newmsg.angular.z)
        
    pub.publish(newmsg)


def main():
    # reference interface globally
    global robot
    arm_config = dict(control_mode='torque')

    rospy.init_node("artificial_potential")
    rospy.loginfo("artificial_potential node started")
    # start robot control
    try:
        # Initialize subscribers to republish joystick inputs (just navigation for now)

        rospy.Subscriber(namespace + twistTopic, Twist, repubTwistCallback)
        rospy.Subscriber(namespace + xyzArmOffsetTopic, Float32MultiArray, xyzArmCallback)
        rospy.Subscriber("/locobot/laser/scan", LaserScan, laserCallback)

    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

if __name__ == "__main__":
    main()
    rospy.spin()
