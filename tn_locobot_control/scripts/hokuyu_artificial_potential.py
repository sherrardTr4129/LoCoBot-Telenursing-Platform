#!/usr/bin/env python
import rospy
from pyrobot import Robot
import time
import math
import numpy as np
from geometry_msgs.msg import Twist
from std_msgs.msg import Float32MultiArray
from sensor_msgs.msg import LaserScan

# define misc variables
namespace = "/pyRobot_web_data/"
twistTopic = "cmd_vel"
xyzArmOffsetTopic = "xyz_arm_offet"
# Laser angle and range constants 
LA_INC = 0.00436940183863
LA_MIN = -1.57079994678
LA_MAX = 1.57079994678
LR_MIN = 0.1
LR_MAX = 30.0
# Maximum obstacle distance and scale factor to use for avoidance behavior
OBS_MAX = 1.0
ETA = 50

pub = rospy.Publisher("/artificial_potential/twist", Twist, queue_size=1)

def xyzArmCallback(msg):
    """
    This function extracts the xyz components of the Float32 array
    message request for cartesian end effector movement, checks for
    workspace compatibility, and republishes a safety-filtered version
    of the command.  Not yet implemented.

    params:
        msg (std_msgs/Float32MultiArray): the recieved message
    returns:
        None
    """
    global robot
    # extract message components and normalize - joystick provides [-100,100] and 
    # we will scale to [-0.1,0.1]
    arm_x = msg.data[0]/5000.0
    arm_y = msg.data[1]/5000.0
    arm_z = msg.data[2]/5000.0

    if (arm_x == 0 and arm_y == 0 and arm_z == 0):
        rospy.loginfo("no arm command to alter")
    
    else:
        rospy.loginfo("arm workspace safety checks not written, doing nothing")

def laserCallback(msg):
    """
    This callback simply stores the latest range return array from the laser 
    rangefinder in the local variable "laser_ranges" for use by other
    functions.
    
    params:
        None
    returns:
        None
    """
    global laser_ranges
    laser_ranges = np.array(msg.ranges)


def repubTwistCallback(msg):
    """
    This function takes in the Twist message generated by user input to control the Locobot's 
    base, biases it to avoid obstacles based on readings from the laser rangefinder using a pseudo-artificial 
    potential field strategy, and publishes the new Twist command.
    
    params:
        None
    returns:
        None
    """
    global laser_ranges
    fwdRev = msg.linear.x
    spin = msg.angular.z
    linear_spin = 0.354 * spin # 354 mm Turtlebot base
    vel_inputs = np.array([fwdRev, linear_spin])
    for i in range(10,laser_ranges.size-10):
        if (laser_ranges[i]<OBS_MAX): # Nearby obstacle detected
            # if (laser_ranges[i]<laser_ranges[i-1] 
            #     and laser_ranges[i]<laser_ranges[i+1]): # Local minimum, object CPA
            if np.argmin(laser_ranges[i-10:i+10])==10:
                #mag = 100/laser_ranges[i] # Use the numerator as the scaling factor for avoidance behavior (currently 10/dist)
                mag = (ETA/2)*pow((1/laser_ranges[i] - (1/OBS_MAX)),2)
                angle = LA_MIN + i*LA_INC
                vel = -math.cos(angle)*mag
                lat = -math.sin(angle)*mag
                vel_inputs = np.append(vel_inputs,[vel,lat])
    rospy.loginfo("vel array: %s", np.array2string(vel_inputs))

    j=0
    out_fwdrev = 0
    out_spin = 0
    while(j<vel_inputs.size):
        out_fwdrev += vel_inputs[j]
        j+=1
        out_spin += vel_inputs[j]
        j+=1

    rospy.loginfo("totals: %s, %s", out_fwdrev, out_spin)
    rospy.loginfo("new: %s, %s", out_fwdrev/vel_inputs.size, out_spin/vel_inputs.size)

    newmsg = Twist()
    newmsg.linear.x = out_fwdrev/vel_inputs.size
    newmsg.angular.z = (out_spin/vel_inputs.size)/0.354
    pub.publish(newmsg)


def main():
    # reference interface globally
    global robot
    arm_config = dict(control_mode='torque')

    rospy.init_node("artificial_potential")
    rospy.loginfo("artificial_potential node started")
    # start robot control
    try:
        # Initialize subscribers to republish joystick inputs (just navigation for now)

        rospy.Subscriber(namespace + twistTopic, Twist, repubTwistCallback)
        rospy.Subscriber(namespace + xyzArmOffsetTopic, Float32MultiArray, xyzArmCallback)
        rospy.Subscriber("/locobot/laser/scan", LaserScan, laserCallback)

    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

if __name__ == "__main__":
    main()
    rospy.spin()
